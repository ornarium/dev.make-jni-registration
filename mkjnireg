#!/usr/bin/perl

use strict;
use warnings;
undef $/;

my @class_list;
my $tabspace = "    ";

# repalce slash to dot character
sub replace_slash_to_dot_path {
  my $arg = shift;
  $arg =~ s/\//./g;
  return $arg;
}

# repalce under-bar to slash character
sub replace_underbar_to_slash_path {
  my $arg = shift;
  $arg =~ s/_/\//g;
  return $arg;
}

# repalce snake case to camel case
sub replace_snake_to_camel_case {
  my $arg = shift;
  $arg =~ s/_([a-z])/\u$1/g;
  $arg =~ s/_1/_/g;
  return $arg;
}

sub make_registration {

  my $file = $_[0];
  my ( $dir, $file_name ) = m/(.*)[\\\/](.+)/ ? ( $1, $2 ) : ( undef, $_ );
  open(my $FH, "<$file") || die "can not open $file";
  my $class_method;
  my $a = <$FH>;
  close($FH);

  while ($a =~ /.+Class:\s*(.+?)\s*\n.+Method:\s*(.+?)\s*\n.+Signature:\s*(.+?)\s*\n.+JNIEXPORT\s*(.+?);/msg) {
    my %data = ( method => $2, signature => $3, method_ref => "JNIEXPORT " . $4);
    push @{$class_method->{$1}}, \%data;
  }

  for (keys %$class_method) {
    my $class = $_;
    push @class_list, $class;

    my $extern_text = "";
    my $methods_name = $class . "Methods";
    my $methods_text = "";
    my $register_text = "";
    my $class_path = replace_underbar_to_slash_path($class);

    for (@{$class_method->{$class}}) {
      my $method = $_->{method};
      my $signature = $_->{signature};
      my $method_ref = $_->{method_ref};

      $extern_text .= "extern $method_ref\n";
      $methods_text .= $tabspace . "{ \"$method\", \"$signature\", $class" . "_$method },";
    }
    
    my $regi_filename = "$dir/$class" . "_registration.h";
    print "[gen] $regi_filename\n";
    open(my $DEF_FH, ">$regi_filename");
    print $DEF_FH "/* DO NOT EDIT THIS FILE - it is machine generated */\n";
    print $DEF_FH "/* Header for class $class_path */\n";
    print $DEF_FH "#include \"../jni_loader.h\"\n";    
    print $DEF_FH "#include <jni.h>\n";
    print $DEF_FH "#ifndef _HEADER_$class" . "_\n";
    print $DEF_FH "#define _HEADER_$class" . "_\n";
    print $DEF_FH "#ifdef _cplusplus\nextern \"C\" {\n#endif\n";
    print $DEF_FH "/* Methods for class $class */\n";
    print $DEF_FH $extern_text;
    if ($methods_text ne "") {
      print $DEF_FH "\n\n/*\n * JNI registration\n */\n";
      print $DEF_FH "static JNINativeMethod $methods_name" . "[] = {\n";
      print $DEF_FH $tabspace . "/* Header for class $class */\n";
      print $DEF_FH $methods_text;
      print $DEF_FH "\n};";
    }
    print $DEF_FH "\n\n";
    print $DEF_FH "int register_$class(JNIEnv* env) {\n";
    print $DEF_FH $tabspace . "return jniRegisterNativeMethods(env, \"$class_path\",\n";
    print $DEF_FH $tabspace x 2 . "$methods_name, \n";
    print $DEF_FH $tabspace x 2 . "sizeof($methods_name)/$methods_name" . "[0]);\n}\n\n";


    print $DEF_FH "#ifdef _cplusplus\n}\n#endif\n";
    print $DEF_FH "#endif";
    close($DEF_FH);
  }
}

sub make_jni_loader {
  use Cwd;
  
  #FIXME: 정확한 relative path가 아닌, 대충 만든 부분
  my $this_path = getcwd . "/";
  my $target_relpath = $_[0];
  $target_relpath =~ s/$this_path//g;
  # if($target_relpath ne "") {
  #   $target_relpath .= "/";
  # }
  
  if (scalar @class_list > 0) {
    open (my $FH, ">$this_path" . "jni_loader.c");
    open (my $HDR_FH, ">$this_path" . "jni_loader.h");
    print $HDR_FH "/* DO NOT EDIT THIS FILE - it is machine generated */\n";

    print $HDR_FH "#ifndef _HEADER_JNI_LOADER_\n";
    print $HDR_FH "#define _HEADER_JNI_LOADER_\n";
    print $HDR_FH "#ifdef _cplusplus\nextern \"C\" {\n#endif\n";
    print $HDR_FH "#include <jni.h>\n\n"

    print $HDR_FH "JNIEXPORT jint JNI_OnLoad(JavaVM * vm, void * reserved);\n"

    print $HDR_FH "\n#ifdef _cplusplus\n}\n#endif\n#endif";
    close($HDR_FH);
    
    print $FH "/* DO NOT EDIT THIS FILE - it is machine generated */\n";
    print $FH "#include \"jni_loader.h\"\n";    
    for(@class_list) {
      print $FH "#include \"$target_relpath/$_" . "_registratition.h\"\n";
    }
    print $FH "\n\n";

    #TODO: 작업필요
#    print $FH "int jni_registerNative() {\n\n}\n";
   # print $FH "extern \"C\" jint JNI_OnLoad(JavaVM * vm, void * reserved) {\n";
   #  print $FH $tabspace . "JNIEnv * env = NULL;\n";
   #  print $FH $tabspace . "jint result = -1;\n\n";
   #  print $FH $tabspace . "if
    print $FH <<end;
extern "C" jint JNI_OnLoad(JavaVM * vm, void * reserved) {
    JNIEnv * env = NULL;
    jint result = -1;

    if(vm->GetEnv((void**)&env, JNI_VERSION_1_4) != JNI_OK) {
        LOGE("GetEnv failed!");
        return result;
    }

end
    
    for(@class_list) {
      print $FH $tabspace . "register_$_(env);\n";
    }
    
    print $FH $tabspace . "return JNI_VERSION_1_4;\n}\n\n";


    close($FH);
  }
}

## main
use Cwd 'abs_path';
my $path = abs_path($ARGV[0]);
if ($path ne "") {
  for (glob($path . "/*.h")) {
    make_registration($_);
  }
  
  make_jni_loader($path);
} else {
  print "path is none";
}

#written by hwiorn.
